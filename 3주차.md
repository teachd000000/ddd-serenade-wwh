# 3주차

## BDD(Behaviour Driven Development)

```
Feature : 테스트에 대상의 기능/책임을 명시
Scenario : 테스트 목적에 대한 상황을 설명
Given : 시나리오 진행에 필요한 값을 설정
When : 시나리오를 진행하는데 필요한 조건을 명시
Then : 시나리오를 완료했을 때 보장해야 하는 결과를 명시
```
---

## 테스트 코드 작성을 위한 툴

- [Mockito features in Korean](https://github.com/mockito/mockito/wiki/Mockito-features-in-Korean)
- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
- [AssertJ - fluent assertions java library](https://assertj.github.io/doc/)

----

## Entity 

- Entity's data 와 Entity's behavior and logic 로 구성되어있음
- 식별자(객체의 상태 중 해당 객체의 고유한 성질을 표현할 수 있는 상태들)를 갖음
- 각 엔티티는 서로 다른 식별자를 갖음

---

## 도메인 모델에 Setter 추가하지 않기

- 도메인 모델에 getter 와 setter 를 무조건 추가하는 것은 좋지 않은 버릇
- Setter 는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 함
- Setter 는 다수의 사용자로 하여금 실수를 유발하게 함
- 도메인 객체가 불완전한 상태로 사용되는 것을 막으려면, 생성 시점에 필요한 것을 전달해 주어야 함

---

## VO(Value Object)

- 밸류 타입은 불변
- Thread safety, Immutable 한 객체
- 의미를 명확하게 표현하거나 두 개 이상의 데이터가 개념적으로 하나인 경우, 밸류 타입을 이용
- 항상 equals(), hashCode() 를 오버라이드 할 것을 권고함
- 밸류 객체의 값을 변경하는 방법은 새로운 밸류 객체를 할당하는 방법밖에 없음

---

## Aggregate

- 도메인으로부터 관련된 객체를 하나로 묶은 군집
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티(애그리거트 루트)를 갖음
- 애그리더트에 속한 객체들은 동일한 라이프 싸이클을 갖음
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않음

---

## Aggregate Root

- 애그리거트에 접근하기 위한 게이트웨이 역할을 함
- 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것
- 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현함
- 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화 할 수 있음
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공함
- 애그리거트가 직접 다른 애그리거트 루트로 접근할 수 없음

---

## Aggregate 참조

- 애그리거트끼리의 참조는 간접 참조를 권장함
- 애그리거트를 직접 참조할 경우, 편리함을 오용할 수 있음
- ID 참조를 사용하면 모든 객체가 직접 참조로 연결되지 않고, 한 애그리거트에 속한 객체들만 참조로 연결됨
- ID 를 이용한 참조 방식을 사용하면 복잡도를 낮추고 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 막을수 있음

---

## Repository

- 구현을 위한 도메인 모델
- 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의함
- 리포지토리는 루트 애그리거트 단위로 존재하며 테이블 단위로 존재하는 것이 아님
- 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 함

---

## 도메인 서비스

- 응용 영역의 서비스가 용용 로직을 다룬다면, 도메인 서비스는 도메인 로직을 다루며 상태 없이 로직만 있음
- 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면, 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러낼 것
- 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있음
- 애그리거트 메서드를 실행할 때, 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 함
- 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 확인해보면 알 수 있음





